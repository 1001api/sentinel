// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: events.sql

package gen

import (
	"context"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :exec
INSERT INTO events (
    event_type,
    event_label,
    page_url,
    element_path,
    element_type,
    ip_addr,
    user_agent,
    browser_name,
    country,
    region,
    city,
    session_id,
    device_type,
    time_on_page,
    screen_resolution,
    fired_at,
    received_at,
    user_id,
    project_id
) VALUES (
    $1,  -- event_type
    $2,  -- event_label
    $3,  -- page_url
    $4,  -- element_path
    $5,  -- element_type
    $6,  -- ip_addr
    $7,  -- user_agent
    $8,  -- browser_name
    $9,  -- country
    $10, -- region
    $11, -- city
    $12, -- session_id
    $13, -- device_type
    $14, -- time_on_page
    $15, -- screen_resolution
    $16, -- fired_at
    $17, -- received_at
    $18, -- user_id
    $19  -- project_id
)
`

type CreateEventParams struct {
	EventType        string
	EventLabel       pgtype.Text
	PageUrl          pgtype.Text
	ElementPath      pgtype.Text
	ElementType      pgtype.Text
	IpAddr           *netip.Addr
	UserAgent        pgtype.Text
	BrowserName      pgtype.Text
	Country          pgtype.Text
	Region           pgtype.Text
	City             pgtype.Text
	SessionID        pgtype.Text
	DeviceType       pgtype.Text
	TimeOnPage       pgtype.Int4
	ScreenResolution pgtype.Text
	FiredAt          time.Time
	ReceivedAt       time.Time
	UserID           uuid.UUID
	ProjectID        uuid.UUID
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) error {
	_, err := q.db.Exec(ctx, createEvent,
		arg.EventType,
		arg.EventLabel,
		arg.PageUrl,
		arg.ElementPath,
		arg.ElementType,
		arg.IpAddr,
		arg.UserAgent,
		arg.BrowserName,
		arg.Country,
		arg.Region,
		arg.City,
		arg.SessionID,
		arg.DeviceType,
		arg.TimeOnPage,
		arg.ScreenResolution,
		arg.FiredAt,
		arg.ReceivedAt,
		arg.UserID,
		arg.ProjectID,
	)
	return err
}

const getEventLastVisitedUser = `-- name: GetEventLastVisitedUser :many
SELECT ip_addr AS ip, received_at AS timestamp
FROM events
WHERE user_id = $2 AND project_id = $1
GROUP BY ip_addr, received_at ORDER BY received_at DESC LIMIT 5
`

type GetEventLastVisitedUserParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetEventLastVisitedUserRow struct {
	Ip        *netip.Addr
	Timestamp time.Time
}

func (q *Queries) GetEventLastVisitedUser(ctx context.Context, arg GetEventLastVisitedUserParams) ([]GetEventLastVisitedUserRow, error) {
	rows, err := q.db.Query(ctx, getEventLastVisitedUser, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventLastVisitedUserRow
	for rows.Next() {
		var i GetEventLastVisitedUserRow
		if err := rows.Scan(&i.Ip, &i.Timestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventMostEventLabel = `-- name: GetEventMostEventLabel :many
SELECT event_label AS name, COUNT(event_label) AS total
FROM events
WHERE event_label IS NOT NULL AND event_label <> ''
AND user_id = $2 AND project_id = $1
GROUP BY event_label ORDER BY COUNT(event_label) DESC LIMIT 5
`

type GetEventMostEventLabelParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetEventMostEventLabelRow struct {
	Name  pgtype.Text
	Total int64
}

func (q *Queries) GetEventMostEventLabel(ctx context.Context, arg GetEventMostEventLabelParams) ([]GetEventMostEventLabelRow, error) {
	rows, err := q.db.Query(ctx, getEventMostEventLabel, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventMostEventLabelRow
	for rows.Next() {
		var i GetEventMostEventLabelRow
		if err := rows.Scan(&i.Name, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventMostEventType = `-- name: GetEventMostEventType :many
SELECT event_type AS name, COUNT(event_type) AS total
FROM events
WHERE event_type IS NOT NULL AND event_type <> ''
AND user_id = $2 AND project_id = $1
GROUP BY event_type ORDER BY COUNT(event_type) DESC LIMIT 5
`

type GetEventMostEventTypeParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetEventMostEventTypeRow struct {
	Name  string
	Total int64
}

func (q *Queries) GetEventMostEventType(ctx context.Context, arg GetEventMostEventTypeParams) ([]GetEventMostEventTypeRow, error) {
	rows, err := q.db.Query(ctx, getEventMostEventType, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventMostEventTypeRow
	for rows.Next() {
		var i GetEventMostEventTypeRow
		if err := rows.Scan(&i.Name, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventMostHitElement = `-- name: GetEventMostHitElement :many
SELECT element_path AS name, COUNT(element_path) AS total
FROM events 
WHERE element_path IS NOT NULL AND element_path <> '' 
AND user_id = $2 AND project_id = $1
GROUP BY element_path ORDER BY COUNT(element_path) DESC LIMIT 5
`

type GetEventMostHitElementParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetEventMostHitElementRow struct {
	Name  pgtype.Text
	Total int64
}

func (q *Queries) GetEventMostHitElement(ctx context.Context, arg GetEventMostHitElementParams) ([]GetEventMostHitElementRow, error) {
	rows, err := q.db.Query(ctx, getEventMostHitElement, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventMostHitElementRow
	for rows.Next() {
		var i GetEventMostHitElementRow
		if err := rows.Scan(&i.Name, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventMostUsedBrowser = `-- name: GetEventMostUsedBrowser :many
SELECT browser_name AS name, COUNT(browser_name) AS total
FROM events
WHERE browser_name IS NOT NULL AND browser_name <> ''
AND user_id = $2 AND project_id = $1
GROUP BY browser_name ORDER BY COUNT(browser_name) DESC LIMIT 5
`

type GetEventMostUsedBrowserParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetEventMostUsedBrowserRow struct {
	Name  pgtype.Text
	Total int64
}

func (q *Queries) GetEventMostUsedBrowser(ctx context.Context, arg GetEventMostUsedBrowserParams) ([]GetEventMostUsedBrowserRow, error) {
	rows, err := q.db.Query(ctx, getEventMostUsedBrowser, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventMostUsedBrowserRow
	for rows.Next() {
		var i GetEventMostUsedBrowserRow
		if err := rows.Scan(&i.Name, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventMostVisitedCity = `-- name: GetEventMostVisitedCity :many
SELECT city AS name, COUNT(city) AS total
FROM events 
WHERE city IS NOT NULL AND city <> '' 
AND user_id = $2 AND project_id = $1
GROUP BY city ORDER BY COUNT(city) DESC LIMIT 5
`

type GetEventMostVisitedCityParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetEventMostVisitedCityRow struct {
	Name  pgtype.Text
	Total int64
}

func (q *Queries) GetEventMostVisitedCity(ctx context.Context, arg GetEventMostVisitedCityParams) ([]GetEventMostVisitedCityRow, error) {
	rows, err := q.db.Query(ctx, getEventMostVisitedCity, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventMostVisitedCityRow
	for rows.Next() {
		var i GetEventMostVisitedCityRow
		if err := rows.Scan(&i.Name, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventMostVisitedCountry = `-- name: GetEventMostVisitedCountry :many
SELECT country AS name, COUNT(country) AS total
FROM events 
WHERE country IS NOT NULL AND country <> ''
AND user_id = $2 AND project_id = $1
GROUP BY country ORDER BY COUNT(country) DESC LIMIT 5
`

type GetEventMostVisitedCountryParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetEventMostVisitedCountryRow struct {
	Name  pgtype.Text
	Total int64
}

func (q *Queries) GetEventMostVisitedCountry(ctx context.Context, arg GetEventMostVisitedCountryParams) ([]GetEventMostVisitedCountryRow, error) {
	rows, err := q.db.Query(ctx, getEventMostVisitedCountry, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventMostVisitedCountryRow
	for rows.Next() {
		var i GetEventMostVisitedCountryRow
		if err := rows.Scan(&i.Name, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventMostVisitedURL = `-- name: GetEventMostVisitedURL :many
SELECT page_url AS name, COUNT(page_url) AS total
FROM events WHERE user_id = $2 AND project_id = $1
GROUP BY page_url ORDER BY COUNT(page_url) DESC LIMIT 5
`

type GetEventMostVisitedURLParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetEventMostVisitedURLRow struct {
	Name  pgtype.Text
	Total int64
}

func (q *Queries) GetEventMostVisitedURL(ctx context.Context, arg GetEventMostVisitedURLParams) ([]GetEventMostVisitedURLRow, error) {
	rows, err := q.db.Query(ctx, getEventMostVisitedURL, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventMostVisitedURLRow
	for rows.Next() {
		var i GetEventMostVisitedURLRow
		if err := rows.Scan(&i.Name, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventSummary = `-- name: GetEventSummary :one
SELECT 
COUNT(e.id) AS total_events,
COUNT(DISTINCT e.ip_addr) AS total_unique_users,
COUNT(DISTINCT e.event_type) AS total_event_type,
COUNT(DISTINCT e.country) AS total_country_visited,
(
    SELECT sub.page_url FROM events AS sub
    WHERE sub.user_id = $2 AND sub.project_id = $1
    GROUP BY sub.page_url ORDER BY COUNT(sub.page_url) DESC LIMIT 1
) AS most_visited_url,
(
    SELECT sub.country FROM events AS sub
    WHERE sub.user_id = $2 AND sub.project_id = $1
    GROUP BY sub.country ORDER BY COUNT(sub.country) DESC LIMIT 1
) AS most_country_visited
FROM events AS e WHERE e.user_id = $2 AND e.project_id = $1
`

type GetEventSummaryParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetEventSummaryRow struct {
	TotalEvents         int64
	TotalUniqueUsers    int64
	TotalEventType      int64
	TotalCountryVisited int64
	MostVisitedUrl      pgtype.Text
	MostCountryVisited  pgtype.Text
}

func (q *Queries) GetEventSummary(ctx context.Context, arg GetEventSummaryParams) (GetEventSummaryRow, error) {
	row := q.db.QueryRow(ctx, getEventSummary, arg.ProjectID, arg.UserID)
	var i GetEventSummaryRow
	err := row.Scan(
		&i.TotalEvents,
		&i.TotalUniqueUsers,
		&i.TotalEventType,
		&i.TotalCountryVisited,
		&i.MostVisitedUrl,
		&i.MostCountryVisited,
	)
	return i, err
}

const getEventSummaryDetailTLDR = `-- name: GetEventSummaryDetailTLDR :one
SELECT 
    COUNT(id) AS total_events,
    COUNT(DISTINCT event_type) AS total_event_type,
    COUNT(DISTINCT ip_addr) AS total_unique_users,
    COUNT(DISTINCT country) AS total_country_visited,
    COUNT(DISTINCT page_url) AS total_page_url
FROM events WHERE user_id = $2 AND project_id = $1
`

type GetEventSummaryDetailTLDRParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetEventSummaryDetailTLDRRow struct {
	TotalEvents         int64
	TotalEventType      int64
	TotalUniqueUsers    int64
	TotalCountryVisited int64
	TotalPageUrl        int64
}

func (q *Queries) GetEventSummaryDetailTLDR(ctx context.Context, arg GetEventSummaryDetailTLDRParams) (GetEventSummaryDetailTLDRRow, error) {
	row := q.db.QueryRow(ctx, getEventSummaryDetailTLDR, arg.ProjectID, arg.UserID)
	var i GetEventSummaryDetailTLDRRow
	err := row.Scan(
		&i.TotalEvents,
		&i.TotalEventType,
		&i.TotalUniqueUsers,
		&i.TotalCountryVisited,
		&i.TotalPageUrl,
	)
	return i, err
}

const getLiveEvents = `-- name: GetLiveEvents :many
SELECT
    p.name,
    e.event_type,
    e.event_label,
    e.page_url,
    e.element_path,
    e.country,
    e.fired_at,
    e.received_at
FROM events AS e
JOIN projects AS p ON e.project_id = p.id
WHERE e.user_id = $1 AND e.received_at >= NOW() - INTERVAL '1 hour'
ORDER BY e.received_at DESC
LIMIT 100
`

type GetLiveEventsRow struct {
	Name        string
	EventType   string
	EventLabel  pgtype.Text
	PageUrl     pgtype.Text
	ElementPath pgtype.Text
	Country     pgtype.Text
	FiredAt     time.Time
	ReceivedAt  time.Time
}

func (q *Queries) GetLiveEvents(ctx context.Context, userID uuid.UUID) ([]GetLiveEventsRow, error) {
	rows, err := q.db.Query(ctx, getLiveEvents, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLiveEventsRow
	for rows.Next() {
		var i GetLiveEventsRow
		if err := rows.Scan(
			&i.Name,
			&i.EventType,
			&i.EventLabel,
			&i.PageUrl,
			&i.ElementPath,
			&i.Country,
			&i.FiredAt,
			&i.ReceivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLiveEventsDetail = `-- name: GetLiveEventsDetail :many
SELECT 
    event_type,
    event_label,
    page_url,
    element_path,
    element_type,
    ip_addr,
    user_agent,
    browser_name,
    country,
    region,
    city,
    device_type,
    time_on_page,
    screen_resolution,
    fired_at,
    received_at
FROM events
WHERE user_id = $2 AND project_id = $1 AND received_at >= NOW() - INTERVAL '1 hour'
ORDER BY received_at DESC
LIMIT 50
`

type GetLiveEventsDetailParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetLiveEventsDetailRow struct {
	EventType        string
	EventLabel       pgtype.Text
	PageUrl          pgtype.Text
	ElementPath      pgtype.Text
	ElementType      pgtype.Text
	IpAddr           *netip.Addr
	UserAgent        pgtype.Text
	BrowserName      pgtype.Text
	Country          pgtype.Text
	Region           pgtype.Text
	City             pgtype.Text
	DeviceType       pgtype.Text
	TimeOnPage       pgtype.Int4
	ScreenResolution pgtype.Text
	FiredAt          time.Time
	ReceivedAt       time.Time
}

func (q *Queries) GetLiveEventsDetail(ctx context.Context, arg GetLiveEventsDetailParams) ([]GetLiveEventsDetailRow, error) {
	rows, err := q.db.Query(ctx, getLiveEventsDetail, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLiveEventsDetailRow
	for rows.Next() {
		var i GetLiveEventsDetailRow
		if err := rows.Scan(
			&i.EventType,
			&i.EventLabel,
			&i.PageUrl,
			&i.ElementPath,
			&i.ElementType,
			&i.IpAddr,
			&i.UserAgent,
			&i.BrowserName,
			&i.Country,
			&i.Region,
			&i.City,
			&i.DeviceType,
			&i.TimeOnPage,
			&i.ScreenResolution,
			&i.FiredAt,
			&i.ReceivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklyEvents = `-- name: GetWeeklyEvents :many
SELECT
  DATE_TRUNC('day', received_at) AS timestamp,
  COUNT(*) AS total
FROM events
WHERE user_id = $2 AND project_id = $1 AND received_at >= NOW() - INTERVAL '7 days'
GROUP BY timestamp ORDER BY timestamp ASC
`

type GetWeeklyEventsParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetWeeklyEventsRow struct {
	Timestamp pgtype.Interval
	Total     int64
}

func (q *Queries) GetWeeklyEvents(ctx context.Context, arg GetWeeklyEventsParams) ([]GetWeeklyEventsRow, error) {
	rows, err := q.db.Query(ctx, getWeeklyEvents, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeeklyEventsRow
	for rows.Next() {
		var i GetWeeklyEventsRow
		if err := rows.Scan(&i.Timestamp, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklyEventsTotal = `-- name: GetWeeklyEventsTotal :one
SELECT
COUNT(id) AS total
FROM events WHERE received_at >= NOW() - INTERVAL '7 days'
AND user_id = $2 AND project_id = $1
`

type GetWeeklyEventsTotalParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

func (q *Queries) GetWeeklyEventsTotal(ctx context.Context, arg GetWeeklyEventsTotalParams) (int64, error) {
	row := q.db.QueryRow(ctx, getWeeklyEventsTotal, arg.ProjectID, arg.UserID)
	var total int64
	err := row.Scan(&total)
	return total, err
}
