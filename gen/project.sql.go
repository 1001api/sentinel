// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: project.sql

package gen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkProjectAggrEligibility = `-- name: CheckProjectAggrEligibility :one
WITH latest_aggr AS (
    SELECT COALESCE(MAX(aggregated_at), '1970-01-01'::timestamp) AS last_aggregated
    FROM project_aggregations AS pa
    WHERE pa.project_id = $1
),
latest_events AS (
    SELECT COUNT(1) AS event_count
    FROM events AS e
    WHERE e.received_at > (SELECT la.last_aggregated FROM latest_aggr AS la)
    AND e.project_id = $1
)
SELECT event_count FROM latest_events
`

func (q *Queries) CheckProjectAggrEligibility(ctx context.Context, projectID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, checkProjectAggrEligibility, projectID)
	var event_count int64
	err := row.Scan(&event_count)
	return event_count, err
}

const checkProjectWithinUserID = `-- name: CheckProjectWithinUserID :one
SELECT EXISTS(SELECT 1 FROM projects WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL)
`

type CheckProjectWithinUserIDParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) CheckProjectWithinUserID(ctx context.Context, arg CheckProjectWithinUserIDParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkProjectWithinUserID, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countProject = `-- name: CountProject :one
SELECT COUNT(*) FROM projects WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountProject(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProject, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectSize = `-- name: CountProjectSize :one
SELECT 
    COALESCE(SUM(pg_column_size(events.*)) / 1024, 0)::bigint AS total_project_size
FROM events 
WHERE user_id = $1 AND project_id = $2
`

type CountProjectSizeParams struct {
	UserID    uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) CountProjectSize(ctx context.Context, arg CountProjectSizeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProjectSize, arg.UserID, arg.ProjectID)
	var total_project_size int64
	err := row.Scan(&total_project_size)
	return total_project_size, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO 
    projects(name, description, url, user_id, created_at)
    VALUES ($1, $2, $3, $4, $5)
RETURNING name, description, created_at
`

type CreateProjectParams struct {
	Name        string
	Description pgtype.Text
	Url         pgtype.Text
	UserID      uuid.UUID
	CreatedAt   pgtype.Timestamptz
}

type CreateProjectRow struct {
	Name        string
	Description pgtype.Text
	CreatedAt   pgtype.Timestamptz
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (CreateProjectRow, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.Name,
		arg.Description,
		arg.Url,
		arg.UserID,
		arg.CreatedAt,
	)
	var i CreateProjectRow
	err := row.Scan(&i.Name, &i.Description, &i.CreatedAt)
	return i, err
}

const createProjectAggr = `-- name: CreateProjectAggr :exec
INSERT INTO project_aggregations (
    project_id, 
    user_id, 
    total_events, 
    total_event_types, 
    total_unique_users, 
    total_locations, 
    total_unique_page_urls, 
    most_visited_urls, 
    most_visited_countries, 
    most_visited_cities, 
    most_visited_regions, 
    most_firing_elements, 
    last_visited_users, 
    most_used_browsers, 
    most_fired_event_types, 
    most_fired_event_labels,
    aggregated_at,
    aggregated_at_str
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
)
`

type CreateProjectAggrParams struct {
	ProjectID            uuid.UUID
	UserID               uuid.UUID
	TotalEvents          int32
	TotalEventTypes      int32
	TotalUniqueUsers     int32
	TotalLocations       int32
	TotalUniquePageUrls  int32
	MostVisitedUrls      []byte
	MostVisitedCountries []byte
	MostVisitedCities    []byte
	MostVisitedRegions   []byte
	MostFiringElements   []byte
	LastVisitedUsers     []byte
	MostUsedBrowsers     []byte
	MostFiredEventTypes  []byte
	MostFiredEventLabels []byte
	AggregatedAt         time.Time
	AggregatedAtStr      string
}

func (q *Queries) CreateProjectAggr(ctx context.Context, arg CreateProjectAggrParams) error {
	_, err := q.db.Exec(ctx, createProjectAggr,
		arg.ProjectID,
		arg.UserID,
		arg.TotalEvents,
		arg.TotalEventTypes,
		arg.TotalUniqueUsers,
		arg.TotalLocations,
		arg.TotalUniquePageUrls,
		arg.MostVisitedUrls,
		arg.MostVisitedCountries,
		arg.MostVisitedCities,
		arg.MostVisitedRegions,
		arg.MostFiringElements,
		arg.LastVisitedUsers,
		arg.MostUsedBrowsers,
		arg.MostFiredEventTypes,
		arg.MostFiredEventLabels,
		arg.AggregatedAt,
		arg.AggregatedAtStr,
	)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
UPDATE projects SET deleted_at = NOW() WHERE user_id = $1 AND id = $2 AND deleted_at IS NULL
`

type DeleteProjectParams struct {
	UserID uuid.UUID
	ID     uuid.UUID
}

func (q *Queries) DeleteProject(ctx context.Context, arg DeleteProjectParams) error {
	_, err := q.db.Exec(ctx, deleteProject, arg.UserID, arg.ID)
	return err
}

const findAllProjects = `-- name: FindAllProjects :many
SELECT id, name, description, url, created_at FROM projects WHERE user_id = $1 AND deleted_at IS NULL
`

type FindAllProjectsRow struct {
	ID          uuid.UUID
	Name        string
	Description pgtype.Text
	Url         pgtype.Text
	CreatedAt   pgtype.Timestamptz
}

func (q *Queries) FindAllProjects(ctx context.Context, userID uuid.UUID) ([]FindAllProjectsRow, error) {
	rows, err := q.db.Query(ctx, findAllProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllProjectsRow
	for rows.Next() {
		var i FindAllProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Url,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProjectAggr = `-- name: FindProjectAggr :many
SELECT id, project_id, user_id, total_events, total_event_types, total_unique_users, total_locations, total_unique_page_urls, most_visited_urls, most_visited_countries, most_visited_cities, most_visited_regions, most_firing_elements, last_visited_users, most_used_browsers, most_fired_event_types, most_fired_event_labels, aggregated_at, aggregated_at_str FROM project_aggregations
WHERE project_id = $1 AND user_id = $2
ORDER BY aggregated_at DESC LIMIT $3
`

type FindProjectAggrParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
	Limit     int32
}

func (q *Queries) FindProjectAggr(ctx context.Context, arg FindProjectAggrParams) ([]ProjectAggregation, error) {
	rows, err := q.db.Query(ctx, findProjectAggr, arg.ProjectID, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectAggregation
	for rows.Next() {
		var i ProjectAggregation
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.UserID,
			&i.TotalEvents,
			&i.TotalEventTypes,
			&i.TotalUniqueUsers,
			&i.TotalLocations,
			&i.TotalUniquePageUrls,
			&i.MostVisitedUrls,
			&i.MostVisitedCountries,
			&i.MostVisitedCities,
			&i.MostVisitedRegions,
			&i.MostFiringElements,
			&i.LastVisitedUsers,
			&i.MostUsedBrowsers,
			&i.MostFiredEventTypes,
			&i.MostFiredEventLabels,
			&i.AggregatedAt,
			&i.AggregatedAtStr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProjectByID = `-- name: FindProjectByID :one
SELECT id, name, description, url, created_at FROM projects WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type FindProjectByIDParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

type FindProjectByIDRow struct {
	ID          uuid.UUID
	Name        string
	Description pgtype.Text
	Url         pgtype.Text
	CreatedAt   pgtype.Timestamptz
}

func (q *Queries) FindProjectByID(ctx context.Context, arg FindProjectByIDParams) (FindProjectByIDRow, error) {
	row := q.db.QueryRow(ctx, findProjectByID, arg.ID, arg.UserID)
	var i FindProjectByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.CreatedAt,
	)
	return i, err
}

const lastProjectDataReceived = `-- name: LastProjectDataReceived :one
SELECT received_at FROM events 
WHERE user_id = $1 AND project_id = $2
ORDER BY received_at DESC LIMIT 1
`

type LastProjectDataReceivedParams struct {
	UserID    uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) LastProjectDataReceived(ctx context.Context, arg LastProjectDataReceivedParams) (time.Time, error) {
	row := q.db.QueryRow(ctx, lastProjectDataReceived, arg.UserID, arg.ProjectID)
	var received_at time.Time
	err := row.Scan(&received_at)
	return received_at, err
}

const updateProject = `-- name: UpdateProject :exec
UPDATE projects SET name = $1, description = $2, url = $3 WHERE id = $4 AND user_id = $5 AND deleted_at IS NULL
`

type UpdateProjectParams struct {
	Name        string
	Description pgtype.Text
	Url         pgtype.Text
	ID          uuid.UUID
	UserID      uuid.UUID
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) error {
	_, err := q.db.Exec(ctx, updateProject,
		arg.Name,
		arg.Description,
		arg.Url,
		arg.ID,
		arg.UserID,
	)
	return err
}
