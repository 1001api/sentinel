// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: project.sql

package gen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkProjectWithinUserID = `-- name: CheckProjectWithinUserID :one
SELECT EXISTS(SELECT 1 FROM projects WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL)
`

type CheckProjectWithinUserIDParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) CheckProjectWithinUserID(ctx context.Context, arg CheckProjectWithinUserIDParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkProjectWithinUserID, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countProject = `-- name: CountProject :one
SELECT COUNT(*) FROM projects WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountProject(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProject, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectSize = `-- name: CountProjectSize :one
SELECT 
    COALESCE(SUM(pg_column_size(events.*)) / 1024, 0)::bigint AS total_project_size
FROM events 
WHERE user_id = $1 AND project_id = $2
`

type CountProjectSizeParams struct {
	UserID    uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) CountProjectSize(ctx context.Context, arg CountProjectSizeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProjectSize, arg.UserID, arg.ProjectID)
	var total_project_size int64
	err := row.Scan(&total_project_size)
	return total_project_size, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO 
    projects(name, description, url, user_id, created_at)
    VALUES ($1, $2, $3, $4, $5)
RETURNING name, description, created_at
`

type CreateProjectParams struct {
	Name        string
	Description pgtype.Text
	Url         pgtype.Text
	UserID      uuid.UUID
	CreatedAt   pgtype.Timestamptz
}

type CreateProjectRow struct {
	Name        string
	Description pgtype.Text
	CreatedAt   pgtype.Timestamptz
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (CreateProjectRow, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.Name,
		arg.Description,
		arg.Url,
		arg.UserID,
		arg.CreatedAt,
	)
	var i CreateProjectRow
	err := row.Scan(&i.Name, &i.Description, &i.CreatedAt)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
UPDATE projects SET deleted_at = NOW() WHERE user_id = $1 AND id = $2 AND deleted_at IS NULL
`

type DeleteProjectParams struct {
	UserID uuid.UUID
	ID     uuid.UUID
}

func (q *Queries) DeleteProject(ctx context.Context, arg DeleteProjectParams) error {
	_, err := q.db.Exec(ctx, deleteProject, arg.UserID, arg.ID)
	return err
}

const findAllProjects = `-- name: FindAllProjects :many
SELECT id, name, description, url, created_at FROM projects WHERE user_id = $1 AND deleted_at IS NULL
`

type FindAllProjectsRow struct {
	ID          uuid.UUID
	Name        string
	Description pgtype.Text
	Url         pgtype.Text
	CreatedAt   pgtype.Timestamptz
}

func (q *Queries) FindAllProjects(ctx context.Context, userID uuid.UUID) ([]FindAllProjectsRow, error) {
	rows, err := q.db.Query(ctx, findAllProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllProjectsRow
	for rows.Next() {
		var i FindAllProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Url,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProjectByID = `-- name: FindProjectByID :one
SELECT id, name, description, url, created_at FROM projects WHERE id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type FindProjectByIDParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

type FindProjectByIDRow struct {
	ID          uuid.UUID
	Name        string
	Description pgtype.Text
	Url         pgtype.Text
	CreatedAt   pgtype.Timestamptz
}

func (q *Queries) FindProjectByID(ctx context.Context, arg FindProjectByIDParams) (FindProjectByIDRow, error) {
	row := q.db.QueryRow(ctx, findProjectByID, arg.ID, arg.UserID)
	var i FindProjectByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Url,
		&i.CreatedAt,
	)
	return i, err
}

const lastProjectDataReceived = `-- name: LastProjectDataReceived :one
SELECT received_at FROM events 
WHERE user_id = $1 AND project_id = $2
ORDER BY received_at DESC LIMIT 1
`

type LastProjectDataReceivedParams struct {
	UserID    uuid.UUID
	ProjectID uuid.UUID
}

func (q *Queries) LastProjectDataReceived(ctx context.Context, arg LastProjectDataReceivedParams) (time.Time, error) {
	row := q.db.QueryRow(ctx, lastProjectDataReceived, arg.UserID, arg.ProjectID)
	var received_at time.Time
	err := row.Scan(&received_at)
	return received_at, err
}

const updateProject = `-- name: UpdateProject :exec
UPDATE projects SET name = $1, description = $2, url = $3 WHERE id = $4 AND user_id = $5 AND deleted_at IS NULL
`

type UpdateProjectParams struct {
	Name        string
	Description pgtype.Text
	Url         pgtype.Text
	ID          uuid.UUID
	UserID      uuid.UUID
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) error {
	_, err := q.db.Exec(ctx, updateProject,
		arg.Name,
		arg.Description,
		arg.Url,
		arg.ID,
		arg.UserID,
	)
	return err
}
