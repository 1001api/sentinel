// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkAdminExist = `-- name: CheckAdminExist :one
SELECT EXISTS(SELECT 1 FROM users WHERE root_user = true)
`

func (q *Queries) CheckAdminExist(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, checkAdminExist)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserIDExist = `-- name: CheckUserIDExist :one
SELECT EXISTS(SELECT 1 FROM users WHERE id = $1)
`

func (q *Queries) CheckUserIDExist(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserIDExist, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users(
    fullname, email, password_hashed, profile_url, root_user, public_key
) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, fullname, email, profile_url
`

type CreateUserParams struct {
	Fullname       string
	Email          string
	PasswordHashed string
	ProfileUrl     pgtype.Text
	RootUser       bool
	PublicKey      string
}

type CreateUserRow struct {
	ID         uuid.UUID
	Fullname   string
	Email      string
	ProfileUrl pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Fullname,
		arg.Email,
		arg.PasswordHashed,
		arg.ProfileUrl,
		arg.RootUser,
		arg.PublicKey,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.Email,
		&i.ProfileUrl,
	)
	return i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, fullname, email, profile_url FROM users WHERE email = $1
`

type FindUserByEmailRow struct {
	ID         uuid.UUID
	Fullname   string
	Email      string
	ProfileUrl pgtype.Text
}

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (FindUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, findUserByEmail, email)
	var i FindUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.Email,
		&i.ProfileUrl,
	)
	return i, err
}

const findUserByEmailWithHash = `-- name: FindUserByEmailWithHash :one
SELECT id, email, password_hashed FROM users WHERE email = $1
`

type FindUserByEmailWithHashRow struct {
	ID             uuid.UUID
	Email          string
	PasswordHashed string
}

func (q *Queries) FindUserByEmailWithHash(ctx context.Context, email string) (FindUserByEmailWithHashRow, error) {
	row := q.db.QueryRow(ctx, findUserByEmailWithHash, email)
	var i FindUserByEmailWithHashRow
	err := row.Scan(&i.ID, &i.Email, &i.PasswordHashed)
	return i, err
}

const findUserByID = `-- name: FindUserByID :one
SELECT id, fullname, email, profile_url FROM users WHERE id = $1
`

type FindUserByIDRow struct {
	ID         uuid.UUID
	Fullname   string
	Email      string
	ProfileUrl pgtype.Text
}

func (q *Queries) FindUserByID(ctx context.Context, id uuid.UUID) (FindUserByIDRow, error) {
	row := q.db.QueryRow(ctx, findUserByID, id)
	var i FindUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.Email,
		&i.ProfileUrl,
	)
	return i, err
}

const findUserByPrivateKey = `-- name: FindUserByPrivateKey :one
SELECT u.id, u.fullname, u.email, u.profile_url FROM users AS u
JOIN api_keys AS k ON u.id = k.user_id
WHERE k.token = $1
`

type FindUserByPrivateKeyRow struct {
	ID         uuid.UUID
	Fullname   string
	Email      string
	ProfileUrl pgtype.Text
}

func (q *Queries) FindUserByPrivateKey(ctx context.Context, token string) (FindUserByPrivateKeyRow, error) {
	row := q.db.QueryRow(ctx, findUserByPrivateKey, token)
	var i FindUserByPrivateKeyRow
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.Email,
		&i.ProfileUrl,
	)
	return i, err
}

const findUserByPublicKey = `-- name: FindUserByPublicKey :one
SELECT id, fullname, email, profile_url FROM users WHERE public_key = $1
`

type FindUserByPublicKeyRow struct {
	ID         uuid.UUID
	Fullname   string
	Email      string
	ProfileUrl pgtype.Text
}

func (q *Queries) FindUserByPublicKey(ctx context.Context, publicKey string) (FindUserByPublicKeyRow, error) {
	row := q.db.QueryRow(ctx, findUserByPublicKey, publicKey)
	var i FindUserByPublicKeyRow
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.Email,
		&i.ProfileUrl,
	)
	return i, err
}

const findUserPublicKey = `-- name: FindUserPublicKey :one
SELECT public_key FROM users WHERE id = $1
`

func (q *Queries) FindUserPublicKey(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, findUserPublicKey, id)
	var public_key string
	err := row.Scan(&public_key)
	return public_key, err
}
