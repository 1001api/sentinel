// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: aggr.sql

package gen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getBriefAggr = `-- name: GetBriefAggr :one
SELECT 
COUNT(e.id) AS total_events,
COUNT(DISTINCT e.ip_addr) AS total_unique_users,
COUNT(DISTINCT e.event_type) AS total_event_type,
COUNT(DISTINCT e.country) AS total_country_visited,
(
    SELECT sub.page_url FROM events AS sub
    WHERE sub.user_id = $2 AND sub.project_id = $1
    GROUP BY sub.page_url ORDER BY COUNT(sub.page_url) DESC LIMIT 1
) AS most_visited_url,
(
    SELECT sub.country FROM events AS sub
    WHERE sub.user_id = $2 AND sub.project_id = $1
    GROUP BY sub.country ORDER BY COUNT(sub.country) DESC LIMIT 1
) AS most_country_visited
FROM events AS e WHERE e.user_id = $2 AND e.project_id = $1
`

type GetBriefAggrParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetBriefAggrRow struct {
	TotalEvents         int64
	TotalUniqueUsers    int64
	TotalEventType      int64
	TotalCountryVisited int64
	MostVisitedUrl      pgtype.Text
	MostCountryVisited  pgtype.Text
}

func (q *Queries) GetBriefAggr(ctx context.Context, arg GetBriefAggrParams) (GetBriefAggrRow, error) {
	row := q.db.QueryRow(ctx, getBriefAggr, arg.ProjectID, arg.UserID)
	var i GetBriefAggrRow
	err := row.Scan(
		&i.TotalEvents,
		&i.TotalUniqueUsers,
		&i.TotalEventType,
		&i.TotalCountryVisited,
		&i.MostVisitedUrl,
		&i.MostCountryVisited,
	)
	return i, err
}

const getDetailAggr = `-- name: GetDetailAggr :many
WITH 
most_visited_url AS (
    SELECT 'most_visited_url' AS query_type, sub.page_url AS name, COUNT(sub.page_url) AS total
    FROM events sub
    WHERE sub.page_url IS NOT NULL AND sub.page_url <> ''
    AND sub.user_id = $2 AND sub.project_id = $1
    GROUP BY sub.page_url 
    ORDER BY COUNT(*) DESC 
    LIMIT 5
),
most_visited_country AS (
    SELECT 'most_visited_country' AS query_type, sub.country AS name, COUNT(sub.country) AS total
    FROM events sub
    WHERE sub.country IS NOT NULL AND sub.country <> ''
    AND sub.user_id = $2 AND sub.project_id = $1
    GROUP BY sub.country 
    ORDER BY COUNT(*) DESC 
    LIMIT 5
),
most_visited_city AS (
    SELECT 'most_visited_city' AS query_type, sub.city AS name, COUNT(sub.city) AS total
    FROM events sub
    WHERE sub.city IS NOT NULL AND sub.city <> '' 
    AND sub.user_id = $2 AND sub.project_id = $1
    GROUP BY sub.city 
    ORDER BY COUNT(*) DESC 
    LIMIT 5
),
most_hit_element AS (
    SELECT 'most_hit_element' AS query_type, sub.element_path AS name, COUNT(sub.element_path) AS total
    FROM events sub
    WHERE sub.element_path IS NOT NULL AND sub.element_path <> '' 
    AND sub.user_id = $2 AND sub.project_id = $1
    GROUP BY sub.element_path 
    ORDER BY COUNT(*) DESC 
    LIMIT 5
),
last_visited_user AS (
    SELECT 'last_visited_user' AS query_type, 
           sub.ip_addr::text AS name, 
           sub.received_at AS timestamp
    FROM events sub
    WHERE sub.ip_addr IS NOT NULL
    AND sub.user_id = $2 AND sub.project_id = $1
    ORDER BY sub.received_at DESC 
    LIMIT 5
),
most_used_browser AS (
    SELECT 'most_used_browser' AS query_type, sub.browser_name AS name, COUNT(sub.browser_name) AS total
    FROM events sub
    WHERE sub.browser_name IS NOT NULL AND sub.browser_name <> ''
    AND sub.user_id = $2 AND sub.project_id = $1
    GROUP BY sub.browser_name 
    ORDER BY COUNT(*) DESC 
    LIMIT 5
),
most_event_type AS (
    SELECT 'most_event_type' AS query_type, sub.event_type AS name, COUNT(sub.event_type) AS total
    FROM events sub
    WHERE sub.event_type IS NOT NULL AND sub.event_type <> ''
    AND sub.user_id = $2 AND sub.project_id = $1
    GROUP BY sub.event_type 
    ORDER BY COUNT(*) DESC 
    LIMIT 5
),
most_event_label AS (
    SELECT 'most_event_label' AS query_type, sub.event_label AS name, COUNT(sub.event_label) AS total
    FROM events sub
    WHERE sub.event_label IS NOT NULL AND sub.event_label <> ''
    AND sub.user_id = $2 AND sub.project_id = $1
    GROUP BY sub.event_label 
    ORDER BY COUNT(*) DESC 
    LIMIT 5
)

SELECT query_type, name, CAST(total AS text) AS total -- Why cast total as text? so it can be used to also hold the timestamp
FROM (
    SELECT query_type, name, total FROM most_visited_url
    UNION ALL SELECT query_type, name, total FROM most_visited_country
    UNION ALL SELECT query_type, name, total FROM most_visited_city
    UNION ALL SELECT query_type, name, total FROM most_hit_element
    UNION ALL SELECT query_type, name, total FROM most_used_browser
    UNION ALL SELECT query_type, name, total FROM most_event_type
    UNION ALL SELECT query_type, name, total FROM most_event_label
) count_queries
UNION ALL

SELECT query_type, name, CAST(timestamp AS text) AS total
FROM last_visited_user
`

type GetDetailAggrParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetDetailAggrRow struct {
	QueryType string
	Name      pgtype.Text
	Total     string
}

func (q *Queries) GetDetailAggr(ctx context.Context, arg GetDetailAggrParams) ([]GetDetailAggrRow, error) {
	rows, err := q.db.Query(ctx, getDetailAggr, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDetailAggrRow
	for rows.Next() {
		var i GetDetailAggrRow
		if err := rows.Scan(&i.QueryType, &i.Name, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalAggr = `-- name: GetTotalAggr :one
SELECT 
    COUNT(id) AS total_events,
    COUNT(DISTINCT event_type) AS total_event_type,
    COUNT(DISTINCT ip_addr) AS total_unique_users,
    COUNT(DISTINCT country) AS total_country_visited,
    COUNT(DISTINCT page_url) AS total_page_url
FROM events WHERE user_id = $2 AND project_id = $1
`

type GetTotalAggrParams struct {
	ProjectID uuid.UUID
	UserID    uuid.UUID
}

type GetTotalAggrRow struct {
	TotalEvents         int64
	TotalEventType      int64
	TotalUniqueUsers    int64
	TotalCountryVisited int64
	TotalPageUrl        int64
}

func (q *Queries) GetTotalAggr(ctx context.Context, arg GetTotalAggrParams) (GetTotalAggrRow, error) {
	row := q.db.QueryRow(ctx, getTotalAggr, arg.ProjectID, arg.UserID)
	var i GetTotalAggrRow
	err := row.Scan(
		&i.TotalEvents,
		&i.TotalEventType,
		&i.TotalUniqueUsers,
		&i.TotalCountryVisited,
		&i.TotalPageUrl,
	)
	return i, err
}
